- mysql
    - 基本的sql语句，了解insert/replace的区别
    - 了解怎么分析sql慢查询，explain结果的分析: 
        - explain分析结果如果发现是优化器预测扫描行数不准确，导致索引选择错误，可以使用analyze table xxx 语句重新分析
        - 也可以使用force 指定索引直接查询(不推荐)
    - 了解事务的隔离级别及相应可能的问题 
    - 了解mvcc是如何解决幻读问题的 
    - 了解B树和B+树的区别以及为什么mysql会选择B+树作为存储结构
    - 了解索引的基本原理，包括聚簇索引和联合索引
    - 了解索引底层的存储结构是怎么样的
    - binlog，redo log，undo log是啥
      
        - binlog: mysql server层的业务日志，记录所有的变更操作
        - redo log: 存储引擎层 innodb中的变更日志, WAL设计，修改底层数据太慢，不如直接记录操作日志，等后续再读日志修改数据，保证事务的持久性
        - undo log: 存储引擎层innodb中的反向记录操作日志，提供 回滚 和 多个行版本控制(MVCC)。比如一条 delete 操作在 undo log 中会对应一条 insert 记录，反之亦然。当 update 操作时，它会记录一条相反的 update 记录。当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。MVCC：当读取的某一行被其他事务锁定时，它可以从 undo log 中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。
        - 不可重复读跟幻读的区别：
        - 一致性是什么意思（满足约束条件，比如余额不能小于0），一致性读？
        - 索引失效有哪些情况，为什么会索引失效https://segmentfault.com/a/1190000021464570
    
- redis
    - 了解redis和mysql之间更新的策略，如双删策略、先删再更新策略，并知道每个策略会有什么问题
    https://www.cnblogs.com/upnote/p/13185047.html
    - 了解redis每种存储结构(字符串、hash、list、set、zset)的底层数据结构
        - 为什么用跳表不用二叉树
        - ziplist怎么查找某个key
        - zset如果是ziplist的时候我怎么找某个key
    - 了解redis的缓存淘汰策略，如redis内存满了，这个时候怎么办，有什么参数可以控制淘汰策略
    - 了解redis持久化方式aof和rdb，明白两者的区别和使用场景
    - 了解如果要同时更新多个key时，有什么方法可以保证原子性？需要了解lua在redis的应用及相应的问题
    - 了解redis集群的架构，进而了解主从的数据是怎么同步，数据分片为什么采用16556个slot平分，如果添加或删除节点会有什么问题，数据分片的算法和一致性hash算法有什么异同https://www.cnblogs.com/rjzheng/p/10360619.html
    https://zhuanlan.zhihu.com/p/129105249
    - redis为什么快，redis的事件驱动有哪些
    - redis热key处理
    - kafka怎么保证快的？
    - 两个线程同时写一个key会怎么样？怎么保证顺序
    
- 网络
    - tcp/udp
        - tcp 为什么是三次握手： 由于信道不稳定，两者之间各需要一次问答才能确认，可以将服务器的回答和提问合并到一个请求，这样就只需要三次就够了。
        - tcp 四次挥手timewait介绍、原因、解决方案： 
          - 介绍： close发起方收到对方返回的关闭确认Fin，返回ACK后进入timewait，等待2MSL后转到closed。
          - 原因两点：1.为了容错，如果对方没有收到ack，则可以再次发送FIN。 2. 为了让旧连接的重复分节在网络中自然消失，如果直接close，然后立刻起了个新的一样的服务，那么报文则不清楚是来自旧的还是新的。
          - 解决方案： 
            - SO_LINGER, 通过设置套接字选项，来设置调用 close 或者 shutdown 关闭连接时的行为。`setsockopt(s,SOL_SOCKET,SO_LINGER, &so_linger,sizeof(so_linger));` linger结构体：`struct linger {int l_onoff; int l_linger;}`
              - 如果l_onoff为 0，那么关闭本选项。l_linger的值被忽略，这对应了默认行为，close 或 shutdown 立即返回。如果在套接字发送缓冲区中有数据残留，系统会将试着把这些数据发送出去。
              - 如果l_onoff为非 0， 且l_linger值也为 0，那么调用 close 后，会立该发送一个 RST 标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了 TIME_WAIT 状态，直接关闭。这种关闭的方式称为“强行关闭”。 在这种情况下，排队数据不会被发送，被动关闭方也不知道对端已经彻底断开。只有当被动关闭方正阻塞在recv()调用上时，接受到 RST 时，会立刻得到一个“connet reset by peer”的异常。
              - 如果l_onoff为非 0， 且l_linger的值也非 0，那么调用 close 后，调用 close 的线程就将阻塞，直到数据被发送出去，或者设置的l_linger计时时间到。
            - net.ipv4.tcp_tw_reuse=1，限制：1. 只适用于连接发起方（C/S 模型中的客户端）；2. 对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用。使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即net.ipv4.tcp_timestamps=1（默认即为 1），TCP 协议也在与时俱进，RFC 1323 中实现了 TCP 拓展规范，以便保证 TCP 的高可用，并引入了新的 TCP 选项，两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。由于引入了时间戳，2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。注意： net.ipv4.tcp_tw_reuse 要慎用，当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉
        - 了解常见的tcp相关内核参数调整及调整位置
        - tcp重传机制：
          - 超时重传：超过RTO重传，RTO是动态变化的，具体看RFC给出的建议算法
          - 快速重传： 三次相同ACK，直接重传，但是不清楚重传之后的哪些数据
          - SACK： 三次相同ACK并在TCP返回头SACK字段告知目前已经收到的之后的数据范围，这样发送方就能知道重传哪部分数据
          - D-SACK： ACK返回的是最新的，但是又收到之前的数据了，使用SACK头告知对方这个数据已经收到过，这个机制可以知道是发出数据丢失还是返回的ACK丢失，知道是不是发出数据网络延迟了
        - tcp滑动窗口与流量控制：TCP 头里有一个字段叫 `Window`，也就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。所以，通常窗口的大小是由接收方的窗口大小来决定的，tcp也是利用窗口来进行流量控制的。
          - 发送窗口： SND.WND(发送窗口大小即返回的Window的大小),  SND.NXT(未发送但是可发送的第一个字节序号), SND.UNA(已发送但是未收到ack的第一个字节),可用窗口大小=SND.WND - (SND.NXT - SND.UNA)，基于这个计算发送窗口
          - 接收窗口： 即可以接收的缓存区大小，返回ACK的时候TCP头字段Window告知大小
          - 窗口关闭问题： 当发送方接收到窗口为0的时候，不会再往接收方发送数据，直到接收方处理完一部分数据后主动返回窗口大小。但是如果接收方返回窗口大小的报文丢失，那么发送方就永远不会发送数据，造成死锁。为了解决这个问题，发送方在窗口为0时会启动一个定时器继续窗口探测，一般3次，每次30-60s，如果不是0，则可以继续发送数据，如果三次都是0，则发送rst包，中断连接。
          - 糊涂窗口问题： 接收方每次接收几个字节，就告知对方窗口大小，这样发送方每次发送几个字节的数据，造成大量浪费，为了解决这个问题可以从两个方面入手： 
            - 让接收方不通告小窗口给发送方： 当窗口大小小于 min( MSS，缓存空间/2 )时，才告知对方窗口大小,否则就是0 
            - 让发送方不发送小数据:  Nagle算法，只要没满足下面条件中的一条，发送方就一直囤积数据
              1. 窗口 >= MSS 或者数据大小 >= MSS。
              2. 收到之前发送数据的ack包
        - 拥塞控制：当网络出现拥堵时，如果继续发送大量数据，则可能会出现包时延，丢失等问题，丢失又会导致重传，加剧网络拥堵，所以需要拥塞控制，防止这种情况下继续发送大量tcp包。为了解决拥塞问题，提出了拥塞窗口的概念
          - 拥塞窗口： 拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。只要网络出现拥塞，窗口就会减小，反之就会增大。只要发送方没有在规定时间内收到ack报文，就会认为出现了拥塞
          - 拥塞控制算法： 
            - 慢启动： 指数增长，当发送方每收到一个ack，拥塞窗口cwnd+=1，直到cwnd >= ssthresh(慢启动门限), 进行拥塞避免算法。
            - 拥塞避免： 线性增长，每当收到一个 ACK 时，cwnd+=1/cwnd。直到网络拥塞出现丢包重传，触发拥塞发生算法。
            - 拥塞发生: 当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种, 两种下的拥塞发生算法也是不一样的。
              - 超时重传： sshthresh = cwnd / 2, cwnd = 1.然后重新慢启动。
              - 快速重传： cwnd /= 2, sshthresh = cwnd.然后进入快速恢复算法
            - 快速恢复: 快速重传和快速恢复一般一起使用：
              - 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）；
              - 重传丢失的数据包；
              - 如果再收到重复的 ACK，那么 cwnd 增加 1；
              - 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；
        - 滑动窗口中的发送窗口和拥塞窗口的区别： 发送窗口反应了作为单 TCP 连接、点对点之间的流量控制模型，它是需要和接收端一起共同协调来调整大小的；而拥塞窗口则是反应了作为多个 TCP 连接共享带宽的拥塞控制模型，它是发送端独立地根据网络状况来动态调整的。在任何一个时刻，TCP 发送缓冲区的数据是否能真正发送出去，至少取决于两个因素，一个是当前的发送窗口大小，另一个是拥塞窗口大小，而 TCP 协议中总是取两者中最小值作为判断依据。
        - 了解tcp状态转移图
        - 了解如何使用udp搭建文件上传服务
        - epoll poll select的优缺点
          - select 有文件描述符上线，默认1024
          - poll打破了上线，缺点和select一样，每次事件到来，需要用户程序轮询所有结果查找具体端口的事件
          - epoll 系统中维护了全局socket红黑树，每次事件到来，会返回对应事件，不需要轮询，而且红黑树查找效率也比用户程序轮询要高
        - epoll水平触发和边缘触发的优缺点及适用场景？
          - 水平触发每次有数据或者可写都会通知，消耗资源
          - 边缘触发只会触发一次，如果数据没有读完只能等下次数据到来才会通知
          - go是用边缘触发
        - accept是在三次握手之前还是之后？之后，客户端三次握手建立链接后就能从accept中拿到socket
        - 了解backlog参数的作用： 允许进程打开的最大的文件句柄数
        - linux查看tcp和udp端口使用情况的命令： netstat 
        - tcp为什么可靠，为什么需要滑动窗口，回报时的ack是什么？
        - tcp三次握手最后一次失败了会怎么样？此时客户端发数据过去服务端会怎么处理？
    - http
        - http访问的整个流程
            - http访问dns解析域名的流程
            - 如果我某个页面访问很卡我会怎么做？
            http2.0https://github.com/zqjflash/http2-protocol
    - 了解cookie和session的区别
        - 了解常见http错误码，如304、400、401、403、419、201、502、500
        https://zhuanlan.zhihu.com/p/45173862
        - 了解http2基本原理，包括帧类型等
        - http与https的区别，对称加密与非对称加密，数字签名。
    
 - golang
     - 了解new和make的区别
     -  了解三色标记回收算法https://www.jianshu.com/p/4c5a303af470
     - 了解channel的底层实现，协程怎么调度的
     - gmp模型，p优先从全局拿还是从别的p偷
     - 了解sync.Map的底层实现
     - hashmap的实现
     - 了解sync.WaitGroup的使用场
     - 了解go调度的原理，GMP模型，stealing work算法及原因，什么时候会触发调度
     - 了解有哪些类型可以作为map的key
     - 了解接口的底层原理
     - 了解context包的使用场景
     - 了解defer的作用
     - 了解go的锁有哪几种，各自的适用场景是什么？
     - 了解什么是逃逸分析
     
 - 设计一个短连接生成系统

     https://www.cnblogs.com/rickiyang/p/12178644.html
