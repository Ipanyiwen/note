### 定义

MySQL是一个**关系型数据库管理系统**，由瑞典[MySQL AB](https://baike.baidu.com/item/MySQL AB/2620844) 公司开发，属于 [Oracle](https://baike.baidu.com/item/Oracle) 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，MySQL所使用的 SQL 语言是用于访问[数据库](https://baike.baidu.com/item/数据库/103728)的最常用标准化语言。

MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。

### 架构图

![](.mysql.assets/mysql_架构图-1639381518363.jpg)

mysql整体架构分为server层和存储引擎层。

**server层：**包括连接器、查询缓存、分析器、优化器、执行器等，涵盖了mysql大多数核心服务功能，所有跨存储引擎的功能都是在这一层实现的，比如存储过程、触发器、视图等。

**存储引擎层:**负责数据的存储和提取，其架构模式是插件式的，支持Innodb、MyISAM、Memory等多个存储引擎。MySQL 5.5.5之后默认存储引擎Innodb。

#### 连接器

用于与客户端建立连接，获取权限，维持与管理链接。连接建立完成后，可以使用show processlist命令查看连接状况。一个连接长时间没有操作，那么连接器就会将它断开，由参数wait_timeout控制，默认8小时。

**长连接：** 连接建立成功后，客户端持续有请求，保持连接，由于连接建立过程比较耗费资源，所以使用过程中尽量减少建立连接的动作，尽量使用长连接。

- **问题：**由于mysql在执行过程中使用的临时内存是管理在连接对象中的，在连接断开之后才会释放，如果长时间不释放可能会导致内存占用太大导致OOM。
- **解决方案：** mysql 5.7之前，可以通过定期断开长连接的方式解决，5.7或者之后的版本，可以使用mysql_reset_connection 来重新初始化链接资源，这个过程是不需要重连和权限校验的。

#### 查询缓存

如果是一个查询请求，当连接建立完成后，MySQL会先查询缓存，看看之前是否执行过该语句，缓存中存在就直接返回给客户端。不存在就往后执行，执行完成后，将执行结果放入查询缓存中。

**不推荐使用查询缓存：** 由于缓存失效十分频繁，只要表中有一条修改就会直接清空整个缓存，所以查询缓存一般适合修改频率非常低的表，比如系统配置表这种。

**MySQL 8.0 删除了查询缓存模块， 从8.0之后彻底没有查询缓存**

**按需使用：** 将query_cache_type 设置为DEMAND，默认所有请求都不使用查询缓存，需要使用的时候使用SQL_CACHE方式`select SQL_CACHE * from T where id = xxx;`

#### 分析器

分析器对sql语句做词法分析，语法分析，判断语句是否正确，如果不准确，返回"ERROR 1064 (42000): You have an error in your SQL syntax"

#### 优化器

通过分析器，已经能正常解析这次请求的内容，然后会进入优化器进行优化处理，比如表中有多索引的情况决定使用哪个索引，多表关联的时候决定各个表的关联顺序

#### 执行器

MySQL通过分析器知道要做什么，通过优化器知道怎么去做，然后进入执行器开始执行语句，执行器会先判断是否有操作这个表的权限，权限校验完成后，执行器就会根据表对应的存储引擎的定义，去使用对应引擎提供的接口，将查询出来的结果集在server层做组合排序等操作后返回给客户端。

#### 存储引擎

MySQL存储引擎是插件式的，对应多种不同的存储引擎如： Innodb、MyISAM、Memory等，存储引擎会提供一系列的接口，给到server层执行，不同的存储引擎支持的能力也不相同，由于Innodb提供了比较好的事务支持，使用人数也是最多的，在MySQL 5.5 之后默认的存储引擎使用的就是Innodb。

#### 日志

MySQL日志中记录着MySQL数据库运行期间发生的变化，除了平时排查错误和记录请求之外，还有用于灾难恢复和主从复制，事务回滚等操作的日志，比较重要的三种日志： bin log、redo log、 undo log。

- binlog: mysql server层的业务日志，记录所有的变更操作, 所有的存储引擎都可以使用，
- redo log: 存储引擎层 innodb中的变更日志, WAL设计，修改底层数据太慢，不如直接记录操作日志，等后续再读日志修改数据，保证事务的持久性，redo log是一个固定大小的环形结构。
  - write pos 是当前记录的位置
  - checkpoint是最早的日志位置
  - write pos 和 checkpoint之间的位置就是可以写入的新的数据的区域
- undo log: 存储引擎层innodb中的反向记录操作日志，提供 回滚 和 多版本并发控制(MVCC)。比如一条 delete 操作在 undo log 中会对应一条 insert 记录，反之亦然。当 update 操作时，它会记录一条相反的 update 记录。当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。MVCC：当读取的某一行被其他事务锁定时，它可以从 undo log 中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。

**二阶段提交：** 为了保证bin log 和 redo log一致，innodb执行完写操作后，写入redo log进入prepare， 然后server执行器写入bin log，写入完成后innodb写入redo log进入commit。这样如果redo log 或者bin log写入过程异常重启后，就能根据bin log是否写入成功，redo log选择提交或者回滚。

事务日志落盘参数： 

1. innodb_flush_log_at_trx_commit=1，每次事务redo log都持久化到磁盘
2. sync_binlog=1，每次事务的binlog都持久化到磁盘

#### 查询流程：

1. 客户端发起连接
2. 连接器鉴定身份，管理连接
3. 查询查询缓存中是否有记录，存在就执行权限校验，是否有表权限，通过后返回给客户端
4. 如果没有命中缓存，那么进入分析器，分析器会对请求做词法分析，然后执行语法分析，判断sql是否合法。
5. 经过分析器后，MySQL已经知道要做什么了，在开始执行前， 会经过优化器处理： 当表有多个索引时候，选择使用哪个索引，多表关联的时候决定连接顺序等。
6. 经过优化器优化过后，语句执行方案就确定下来了，进入执行器阶段，执行器开始执行的时候会先判断是否有表权限，然后执行器根据表的存储引擎定义找到对应的存储引擎，调用存储引擎接口取对应的数据。然后根据请求执行一些排序处理等，封装返回格式返回。

#### 更新流程（Innodb）：

1. 客户端发起连接
2. 连接器鉴定身份，管理连接
3. 进入分析器，分析器会对请求做词法分析，然后执行语法分析，判断sql是否合法。
4. 然后清空对应表的查询缓存
5. 经过分析器后，MySQL已经知道要做什么了，在开始执行前， 会经过优化器处理： 当表有多个索引时候，选择使用哪个索引，多表关联的时候决定连接顺序等。
6. 经过优化器优化过后，语句执行方案就确定下来了，进入执行器阶段，执行器开始执行的时候会先判断是否有表权限，然后执行器根据表的存储引擎定义找到对应的存储引擎，调用存储引擎接口修改对应行的数据。
7. 存储引擎先判断该行是否在内存中，如果不在则从磁盘读入内存，修改该行数据，然后写入redo log，redo log 属于prepare状态，这时执行器会写入binlog，写入完成后，调用存储引擎接口提交事务，此时存储引擎将redo log改为commit状态。到此就更新完成

**事务隔离级别：**

| 隔离级别                   | 描述                                                         | 问题                                                         |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 读未提交(read uncommitted) | 一个事务还没提交时，它做的变更就能被别的事务看到。           | 脏读：读到没有提交的数据                                     |
| 读已提交(read committed)   | 一个事务提交之后，它做的变更才会被其他事务看到。             | 不可重复读： 同一个事务两次读同一个数据，值不一样            |
| 可重复读(repeatable read)  | 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。在事务启动的时候会开启一个read-view ， | 幻读： 事务A查询内容，之后事务B插入了数据，导致事务A的修改相关数据操作失败，但是查询还是不存在。 |
| 串行化(serializable)       | 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 |                                                              |

**事务隔离级别实现**：数据库里面会创建一个MVCC一致性读视图(consistent read view)，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

**MVCC一致性视图实现：**

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。数据表中的一行记录，其实可能是有多个版本的，每个版本有自己的raw trx_id, 而这个多版本的方式就是undo log实现的，每次更新操作都往undo log写入反向记录，然后读取的时候依据视图来判断当前行数据是否可见，不可见执行undo log中的记录就回到了上一个版本，直到找到合法的可见值。

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：

1. 版本未提交，不可见；
2. 版本已提交，但是是在视图创建后提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。

#### 索引：

**B+树：**mysql索引使用的是B+树，原因是为了减少磁盘访问次数(N叉树)和能够范围查询(B+树)。mysql设置一个节点大小为16K(一页)，假设bigint索引，就算叶子节点只放一行数据(16K),那么3层高的树可以放136w的数据，正常情况下一行数据远达不到16K，假设一行数据1K，那么三层可以放下2190w的数据。计算方式： bigint索引8个字节，指针6个字节，所以一页可以放16  * 1024 / (8 + 6) = 1170个数据，3层高的树，最下一层放数据，那么可以放下的索引个数为： 1170 *1170 *一页可以存储的行数。由于根节点的叶肯定在内存中，所以2000w的数据也只用访问两次磁盘就能获取到对应数据。

**主键索引：**

**普通索引：**

**唯一索引：**

**全文索引：**

**组合索引：**

**聚簇索引:**

**覆盖索引：**

**索引下推：**

**最左前缀：**

**回表：**

